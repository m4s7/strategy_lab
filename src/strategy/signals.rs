//! Trading signals and indicators

use chrono::{DateTime, Utc};
use rust_decimal::Decimal;
use serde::{Deserialize, Serialize};

/// Trading signal generated by strategies
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Signal {
    /// Signal type
    pub signal_type: SignalType,
    
    /// Signal strength (0.0 to 1.0)
    pub strength: f64,
    
    /// Price at signal generation
    pub price: Decimal,
    
    /// Timestamp
    pub timestamp: DateTime<Utc>,
    
    /// Reason for signal
    pub reason: String,
    
    /// Additional metadata
    pub metadata: SignalMetadata,
}

impl Signal {
    /// Create a new signal
    pub fn new(signal_type: SignalType, strength: f64, price: Decimal, reason: String) -> Self {
        Self {
            signal_type,
            strength: strength.clamp(0.0, 1.0),
            price,
            timestamp: Utc::now(),
            reason,
            metadata: SignalMetadata::default(),
        }
    }
    
    /// Create a long signal
    pub fn long(strength: f64, price: Decimal, reason: String) -> Self {
        Self::new(SignalType::Long, strength, price, reason)
    }
    
    /// Create a short signal
    pub fn short(strength: f64, price: Decimal, reason: String) -> Self {
        Self::new(SignalType::Short, strength, price, reason)
    }
    
    /// Create an exit signal
    pub fn exit(price: Decimal, reason: String) -> Self {
        Self::new(SignalType::Exit, 1.0, price, reason)
    }
    
    /// Add metadata to signal
    pub fn with_metadata(mut self, metadata: SignalMetadata) -> Self {
        self.metadata = metadata;
        self
    }
}

/// Types of trading signals
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum SignalType {
    /// Go long (buy)
    Long,
    
    /// Go short (sell)
    Short,
    
    /// Exit current position
    Exit,
    
    /// No action
    Hold,
    
    /// Scale in (add to position)
    ScaleIn,
    
    /// Scale out (reduce position)
    ScaleOut,
}

/// Additional signal metadata
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct SignalMetadata {
    /// Order book imbalance at signal time
    pub imbalance: Option<f64>,
    
    /// Spread at signal time
    pub spread: Option<Decimal>,
    
    /// Volume at signal time
    pub volume: Option<i32>,
    
    /// Confidence level (0.0 to 1.0)
    pub confidence: Option<f64>,
    
    /// Risk score (0.0 to 1.0)
    pub risk_score: Option<f64>,
    
    /// Supporting indicators
    pub indicators: Vec<IndicatorValue>,
}

/// Value from a technical indicator
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IndicatorValue {
    pub name: String,
    pub value: f64,
    pub timestamp: DateTime<Utc>,
}

/// Signal aggregator for combining multiple signals
pub struct SignalAggregator {
    signals: Vec<(Signal, f64)>, // (signal, weight)
}

impl SignalAggregator {
    pub fn new() -> Self {
        Self {
            signals: Vec::new(),
        }
    }
    
    /// Add a signal with weight
    pub fn add_signal(&mut self, signal: Signal, weight: f64) {
        self.signals.push((signal, weight));
    }
    
    /// Aggregate signals into a single decision
    pub fn aggregate(&self) -> Option<Signal> {
        if self.signals.is_empty() {
            return None;
        }
        
        let mut long_score = 0.0;
        let mut short_score = 0.0;
        let mut exit_score = 0.0;
        let mut total_weight = 0.0;
        let mut latest_price = Decimal::ZERO;
        let mut reasons = Vec::new();
        
        for (signal, weight) in &self.signals {
            total_weight += weight;
            latest_price = signal.price;
            
            match signal.signal_type {
                SignalType::Long => long_score += signal.strength * weight,
                SignalType::Short => short_score += signal.strength * weight,
                SignalType::Exit => exit_score += signal.strength * weight,
                _ => {}
            }
            
            reasons.push(signal.reason.clone());
        }
        
        if total_weight == 0.0 {
            return None;
        }
        
        // Normalize scores
        long_score /= total_weight;
        short_score /= total_weight;
        exit_score /= total_weight;
        
        // Determine strongest signal
        if exit_score > 0.5 {
            Some(Signal::exit(latest_price, reasons.join("; ")))
        } else if long_score > short_score && long_score > 0.3 {
            Some(Signal::long(long_score, latest_price, reasons.join("; ")))
        } else if short_score > long_score && short_score > 0.3 {
            Some(Signal::short(short_score, latest_price, reasons.join("; ")))
        } else {
            None
        }
    }
    
    /// Clear all signals
    pub fn clear(&mut self) {
        self.signals.clear();
    }
}